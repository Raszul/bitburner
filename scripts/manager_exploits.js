/** @param {NS} ns 
 * 
 *  @RAM: 2.1 GB
 *  @Version: 2.0.0
 *  @Author: Raszul
 **/
export async function main(ns) {
	function evaluateTargetServers(targetServers) {
		var evaluatedTargetServerList = [];
		var sortedTargetServerList = [];

		for (var target of targetServers) {
			if (undefined == target) continue;
			if ('' == target) continue;
			if (!ns.serverExists(target)) continue;
			if (0 >= ns.getServerMaxMoney(target)) continue;
			if (evaluatedTargetServerList.includes(target)) continue;


			var targetMaxMoney = ns.getServerMaxMoney(target);
			var targetMinSecurity = ns.getServerMinSecurityLevel(target);
			/**
						var weight = targetMaxMoney / targetMinSecurity;
			
						if (ns.fileExists('/Formulas.exe', 'home')) {
							var pl = ns.getPlayer();
							var so = ns.getServer(target);
							so.hackDifficulty = so.minDifficulty;
			
							weight = serverMaxMoney / ns.formulas.hacking.weakenTime(so, pl) * ns.formulas.hacking.hackChance(so, pl);
						} else {
							if (ns.getServerRequiredHackingLevel(target) > ns.getHackingLevel() / 2) weight = 0;
						}
			
						if (0 == weight) continue;
			
						evaluatedTargetServerList.push([target, weight]); // */

			var lHackThreads = Math.floor(ns.hackAnalyzeThreads(target, targetMaxMoney * (HACK_PERCENT / ns.getPlayer().mults.hacking_money)));
			var lweakThreads1 = Math.ceil((lHackThreads / 25));
			var lgrowThreads = ns.growthAnalyze(target, Math.floor(targetMaxMoney / (targetMaxMoney - (targetMaxMoney * HACK_PERCENT))));
			var lweakThreads1 = Math.ceil((lgrowThreads / 12.5));

			var totalThreads = lHackThreads + lweakThreads1 + lgrowThreads + lweakThreads1;
			var timePerHack = ns.getHackTime(target) * 4.1 / ns.getPlayer().mults.hacking_speed;

			var cashPerThreadPerSecond = targetMaxMoney / (totalThreads * timePerHack);

			evaluatedTargetServerList.push([target, cashPerThreadPerSecond]);
		}

		evaluatedTargetServerList.sort((a, b) => {
			if (a[1] == b[1]) {
				return a[0].toUpperCase().localeCompare(b[0].toUpperCase());
			} else {
				return b[1] - a[1];
			}
		});

		for (var a = 0; a < evaluatedTargetServerList.length; a++) {
			sortedTargetServerList.push(evaluatedTargetServerList[a][0]);
		}

		//spread the primary target
		ns.clearPort(1);
		ns.writePort(1, sortedTargetServerList[0]);

		return sortedTargetServerList;
	}

	function updateHostServerList() {
		var hostServerList = [['home', ns.getServerMaxRam('home') - 32]];

		var purchasedServerList = ns.getPurchasedServers();
		for (var server of purchasedServerList) {
			if (undefined == server) continue;
			if ('' == server) continue;
			if (!ns.serverExists(server)) continue;
			if (0 >= ns.getServerMaxRam(server)) continue;
			if ('home' == server) continue;
			var serverRam = ns.getServerMaxRam(server);
			if (0 >= serverRam) continue;

			hostServerList.push([server, serverRam]);
		}

		var hackedServerList = ns.read(FILE_HACKED_SERVERS).split(',').filter(s => s != '');
		for (var server of hackedServerList) {
			if (!ns.serverExists(server)) continue;
			if (!ns.hasRootAccess(server)) continue;
			if ('home' == server) continue;
			var serverRam = ns.getServerMaxRam(server);
			if (0 >= serverRam) continue;

			hostServerList.push([server, serverRam]);
		}

		//sort list by max ram first, then alphabetically second
		hostServerList.sort((a, b) => {
			if (a[1] == b[1]) {
				return a[0].toUpperCase().localeCompare(b[0].toUpperCase());
			} else {
				return b[1] - a[1];
			}
		})

		//simplify list
		var finalHostServerList = [];
		for (var a = 0; a < hostServerList.length; a++) {
			if (0 >= finalHostServerList.length) {
				finalHostServerList = [hostServerList[a][0]];
			} else {
				//make sure all entries are unique
				if (finalHostServerList.includes(hostServerList[a][0])) continue;


				finalHostServerList.push(hostServerList[a][0]);
			}
		}

		return finalHostServerList;
	}

	function updateTargetServerList() {
		var targetServerList = ['foodnstuff'];

		var hackedServerList = ns.read(FILE_HACKED_SERVERS).split(',').filter(s => s != '');
		for (var server of hackedServerList) {
			if (undefined == server) continue;
			if ('' == server) continue;
			if (!ns.serverExists(server)) continue;
			if (!ns.hasRootAccess(server)) continue;
			if (!(0 < ns.getServerMaxMoney(server))) continue;
			if (targetServerList.includes(server)) continue
			if (ns.getServerRequiredHackingLevel(server) > ns.getHackingLevel()) continue;

			targetServerList.push(server);
		}

		//sort targets by best target DESC then return the list
		return evaluateTargetServers(targetServerList);
	}

	function getAvailableRam(server) {
		var serverMaxRam = ns.getServerMaxRam(server);
		var serverUsedRam = ns.getServerUsedRam(server);
		if ('home' == server) serverMaxRam -= 32;
		return (serverMaxRam - serverUsedRam);
	}
	function getMaxThreads(server, script) {
		var serverRam = getAvailableRam(server);
		var scriptRam = ns.getScriptRam(script);

		return Math.floor(serverRam / scriptRam);
	}

	function calculateServerGrowth(server, threads, p, cores = 1) {
		const ServerBaseGrowthRate = 1.03;
		const ServerMaxGrowthRate = 1.0035
		const ServerGrowthRate = 1;
		const numServerGrowthCycles = Math.max(Math.floor(threads), 0);

		//Get adjusted growth rate, which accounts for server security
		const growthRate = ServerBaseGrowthRate;
		let adjGrowthRate = 1 + (growthRate - 1) / server.hackDifficulty;
		if (adjGrowthRate > ServerMaxGrowthRate) {
			adjGrowthRate = ServerMaxGrowthRate;
		}

		//Calculate adjusted server growth rate based on parameters
		const serverGrowthPercentage = server.serverGrowth / 100;
		const numServerGrowthCyclesAdjusted = numServerGrowthCycles * serverGrowthPercentage * ServerGrowthRate;

		//Apply serverGrowth for the calculated number of growth cycles
		const coreBonus = 1 + (cores - 1) / 16;
		return Math.pow(adjGrowthRate, numServerGrowthCyclesAdjusted * 1 /**p.hacking_grow_mult**/ * coreBonus);
	}

	ns.disableLog('ALL');
	ns.clearLog();

	const FILE_HACKED_SERVERS = '/data/list_hackedServers.txt';
	const SCRIPT_HACK = '/scripts/helpers/hack.js';
	const SCRIPT_GROW = '/scripts/helpers/grow.js';
	const SCRIPT_WEAKEN = '/scripts/helpers/weaken.js';
	const ACTIVITY_SYMBOL = ['-', '\\', '|', '/'];
	const DELAY = 25;
	const HACK_PERCENT = 0.25;

	const exploitScriptCount = Math.floor(parseInt(ns.args[0]) / 4);

	var targetIndex = 0;
	var targetServerList = [];
	var hostServerList = [];

	var a = 0;

	if (!isNaN(exploitScriptCount)) targetIndex = exploitScriptCount;


	while (true) {
		ns.clearLog();
		ns.print("Exploit Manager " + ACTIVITY_SYMBOL[a]);
		ns.print(" ");

		ns.print("  preparing host server list...");
		hostServerList = updateHostServerList();

		ns.print("    installing scripts on hosts...");
		for (var host of hostServerList) {
			if (!ns.fileExists(SCRIPT_HACK, host)) ns.scp(SCRIPT_HACK, host);
			if (!ns.fileExists(SCRIPT_GROW, host)) ns.scp(SCRIPT_GROW, host);
			if (!ns.fileExists(SCRIPT_WEAKEN, host)) ns.scp(SCRIPT_WEAKEN, host);
		}

		ns.print("  preparing target list...");
		targetServerList = updateTargetServerList();
		if (targetIndex > targetServerList.length && targetServerList.length > 0) targetIndex = exploitScriptCount % targetServerList.length;
		ns.print(" ");

		ns.print("    target: " + targetServerList[targetIndex]);
		ns.print(" ");

		var playerObject = ns.getPlayer();
		var targetServerObject = ns.getServer(targetServerList[targetIndex]);
		var weakenTime = ns.getWeakenTime(targetServerList[targetIndex])/playerObject.mults.hacking_speed;
		if (ns.fileExists('Formulas.exe', 'home')) {
			hackTime = ns.formulas.hacking.weakenTime(targetServerObject, playerObject);
		}
		targetServerObject.hackDifficulty = targetServerObject.minDifficulty;
		targetServerObject.moneyAvailable = targetServerObject.moneyMax * (1 - HACK_PERCENT);

		var hackThreads = Math.max(1, Math.floor(ns.hackAnalyzeThreads(targetServerList[targetIndex], ns.getServerMaxMoney(targetServerList[targetIndex]) * (HACK_PERCENT / playerObject.mults.hacking_money))));
		if (ns.fileExists('Formulas.exe', 'home')) {
			var hackPercentPerThread = ns.formulas.hacking.hackPercent(targetServerObject, playerObject);
			hackThreads = Math.max(1, Math.floor(HACK_PERCENT / hackPercentPerThread));
		}
		var hackTime = ns.getHackTime(targetServerList[targetIndex])/playerObject.mults.hacking_speed;
		if (ns.fileExists('Formulas.exe', 'home')) {
			hackTime = ns.formulas.hacking.hackTime(targetServerObject, playerObject);
		}

		var batchStack = [
			[SCRIPT_HACK, 'hacking', hackThreads], //script, task name, number of threads to use
			[SCRIPT_GROW, 'growing', ns.getServerMaxMoney(targetServerList[targetIndex]) - ns.getServerMoneyAvailable(targetServerList[targetIndex])], //script, task name, money still to recover
			[SCRIPT_WEAKEN, 'weakening', ns.getServerSecurityLevel(targetServerList[targetIndex]) - ns.getServerMinSecurityLevel(targetServerList[targetIndex])] //script, task name, amount of security to negate
		];

		var currentBestTarget = targetServerList[targetIndex];
		var newBestTarget = currentBestTarget;
		while (true) {
			ns.clearLog();
			ns.print("Exploit Manager " + ACTIVITY_SYMBOL[a]);
			ns.print(" ");
			ns.print("  batching server: " + targetServerList[targetIndex]);

			ns.print("    updating server lists...");
			hostServerList = updateHostServerList();
			targetServerList = updateTargetServerList();
			if (targetIndex > targetServerList.length && targetServerList.length > 0) targetIndex = exploitScriptCount % targetServerList.length;

			ns.print("      ensuring hosts are ready...");
			for (var host of hostServerList) {
				if (!ns.fileExists(SCRIPT_HACK, host)) ns.scp(SCRIPT_HACK, host);
				if (!ns.fileExists(SCRIPT_GROW, host)) ns.scp(SCRIPT_GROW, host);
				if (!ns.fileExists(SCRIPT_WEAKEN, host)) ns.scp(SCRIPT_WEAKEN, host);
			}
			ns.print("      " + hostServerList.length + " hosts found.");
			ns.print("      " + targetServerList.length + " targets found.");


			playerObject = ns.getPlayer();
			newBestTarget = targetServerList[targetIndex];
			if (currentBestTarget != newBestTarget) {
				currentBestTarget = newBestTarget;

				targetServerObject = ns.getServer(targetServerList[targetIndex]);
				weakenTime = ns.getWeakenTime(targetServerList[targetIndex]) / playerObject.mults.hacking_speed;
				if (ns.fileExists('Formulas.exe', 'home')) {
					hackTime = ns.formulas.hacking.weakenTime(targetServerObject, playerObject);
				}
				targetServerObject.hackDifficulty = targetServerObject.minDifficulty;
				targetServerObject.moneyAvailable = targetServerObject.moneyMax * (1 - HACK_PERCENT);

				hackThreads = Math.max(1, Math.floor(ns.hackAnalyzeThreads(targetServerList[targetIndex], ns.getServerMaxMoney(targetServerList[targetIndex]) * (HACK_PERCENT / playerObject.mults.hacking_money))));
				if (ns.fileExists('Formulas.exe', 'home')) {
					var hackPercentPerThread = ns.formulas.hacking.hackPercent(targetServerObject, playerObject);
					hackThreads = Math.max(1, Math.floor(HACK_PERCENT / hackPercentPerThread));
				}
				hackTime = ns.getHackTime(targetServerList[targetIndex]) / playerObject.mults.hacking_speed;
				if (ns.fileExists('Formulas.exe', 'home')) {
					hackTime = ns.formulas.hacking.hackTime(targetServerObject, playerObject);
				}

				batchStack = [
					[SCRIPT_HACK, 'hacking', hackThreads], //script, task name, number of threads to use
					[SCRIPT_GROW, 'growing', ns.getServerMaxMoney(targetServerList[targetIndex]) - ns.getServerMoneyAvailable(targetServerList[targetIndex])], //script, task name, money still to recover
					[SCRIPT_WEAKEN, 'weakening', ns.getServerSecurityLevel(targetServerList[targetIndex]) - ns.getServerMinSecurityLevel(targetServerList[targetIndex])] //script, task name, amount of security to negate
				];
			}

			var nextLanding = weakenTime + 3000 + performance.now();
			var growthEstimate;
			var weakenThreads;
			var growThreadsN;
			var hackThreads;
			var useThreads;
			var stolenMoney;

			ns.print(" ");
			ns.print("    applying batches...");
			ns.print("      grow needed: $" + ns.formatNumber(batchStack[1][2]));
			ns.print("      security:     " + ns.formatNumber(batchStack[2][2]));

			var cancel = false;
			for (var host of hostServerList) {
				if (cancel) break;
				if (!ns.serverExists(host)) break;

				if (0.9 <= ns.getServerUsedRam(host) / ns.getServerMaxRam(host)) continue;
				if (4 >= getAvailableRam(host)) continue;

				var timeOnServer = 0;
				while (0.9 > ns.getServerUsedRam(host) / ns.getServerMaxRam(host) && 4 < getAvailableRam(host)) {
					var newHostListLength = updateHostServerList().length;
					if (newHostListLength != hostServerList.length) {
						ns.toast("Host server list changed.", 'error', 500);
						cancel = true;
						break;
					}
					if (!ns.serverExists(host)) {
						cancel = true;
						break;
					}

					useThreads = 0;


					//check if we have security to get rid of left on the batch stack
					if (batchStack[2][2] > 0) {
						weakenThreads = Math.ceil(20 * batchStack[2][2]);
						useThreads = Math.floor(Math.min(weakenThreads, getMaxThreads(host, batchStack[2][0])));

						if (0 < useThreads) {
							//reduce amoun of weakening still required
							batchStack[2][2] = Math.max(0, batchStack[2][2] - ns.weakenAnalyze(useThreads));

							//weaken security
							ns.exec(batchStack[2][0], host, useThreads, targetServerList[targetIndex], nextLanding, hackTime);

							await ns.sleep(DELAY * 2);
							timeOnServer += DELAY * 2;
							nextLanding = weakenTime + 3000 + performance.now();
						}
					} else if (batchStack[1][2] > 0) { //check if we still got growing left to do
						growThreadsN = Math.ceil(ns.growthAnalyze(targetServerList[targetIndex], Math.max(1, ns.getServerMaxMoney(targetServerList[targetIndex]) / (ns.getServerMaxMoney(targetServerList[targetIndex]) - batchStack[1][2]))));
						useThreads = Math.floor(Math.min(getMaxThreads(host, batchStack[1][0]), growThreadsN));

						if (0 < useThreads) {
							//task batch stack to negate the security increase
							batchStack[2][2] = Math.ceil(useThreads / 12.5);

							//reduce growth still needed
							growthEstimate = Math.max(0, playerObject.mults.hacking_grow * calculateServerGrowth(ns.getServer(targetServerList[targetIndex]), useThreads, ns.getPlayer()) - 1);
							batchStack[1][2] = Math.max(0, batchStack[1][2] - Math.floor(0.95 * (ns.getServerMaxMoney(targetServerList[targetIndex]) - batchStack[1][2]) * growthEstimate));

							//grow cash
							ns.exec(batchStack[1][0], host, useThreads, targetServerList[targetIndex], nextLanding, hackTime);

							await ns.sleep(DELAY * 2);
							timeOnServer += DELAY * 2;
							nextLanding = weakenTime + 3000 + performance.now();
						}
					} else { //if everything is ready, hack some more cash
						hackThreads = batchStack[0][2];
						useThreads = Math.floor(Math.min(hackThreads, getMaxThreads(host, batchStack[0][0])));
						stolenMoney = Math.min(ns.getServerMaxMoney(targetServerList[targetIndex]) - 1, playerObject.mults.hacking_money * useThreads * ns.getServerMaxMoney(targetServerList[targetIndex]) * ns.hackAnalyze(targetServerList[targetIndex]));

						if (0 < useThreads) {
							//task batch stack to regrow the money
							batchStack[1][2] = stolenMoney;
							//task batch stack to negate the security increase
							batchStack[2][2] = Math.ceil(useThreads / 25);

							//steal cash
							ns.exec(batchStack[0][0], host, useThreads, targetServerList[targetIndex], nextLanding, hackTime);

							await ns.sleep(DELAY * 2);
							timeOnServer += DELAY * 2;
							nextLanding = weakenTime + 3000 + performance.now();
						}
					}
					await ns.sleep(1);
					timeOnServer += 1;
					nextLanding = weakenTime + 3000 + performance.now();

					if (5000 < timeOnServer || 0 == ns.getServerUsedRam(host) || Infinity == ns.getServerMaxRam(host)) {
						cancel = true;
						break;
					}
				}
				await ns.sleep(1);
				nextLanding = weakenTime + 3000 + performance.now();
			}

			await ns.sleep(9);
			nextLanding = weakenTime + 3000 + performance.now();

			a++;
			if (ACTIVITY_SYMBOL.length <= a) a = 0;
		}



		await ns.sleep(999);
		a++;
		if (ACTIVITY_SYMBOL.length <= a) a = 0;
	}
}