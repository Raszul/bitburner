/** @param {NS} ns **/
export async function main(ns) {
    function updateHostServerList() {
		var hostServerList = [['home', ns.getServerMaxRam('home') - 32]];

		var purchasedServerList = ns.getPurchasedServers();
		for (var server of purchasedServerList) {
			if (undefined == server) continue;
			if ('' == server) continue;
			if (!ns.serverExists(server)) continue;
			if (0 >= ns.getServerMaxRam(server)) continue;
			if ('home' == server) continue;
			var serverRam = ns.getServerMaxRam(server);
			if (0 >= serverRam) continue;

			hostServerList.push([server, serverRam]);
		}

		var hackedServerList = ns.read(FILE_HACKED_SERVERS).split(',').filter(s => s != '');
		for (var server of hackedServerList) {
			if (!ns.serverExists(server)) continue;
			if (!ns.hasRootAccess(server)) continue;
			if ('home' == server) continue;
			var serverRam = ns.getServerMaxRam(server);
			if (0 >= serverRam) continue;

			hostServerList.push([server, serverRam]);
		}

		//sort list by max ram first, then alphabetically second
		hostServerList.sort((a, b) => {
			if (a[1] == b[1]) {
				return a[0].toUpperCase().localeCompare(b[0].toUpperCase());
			} else {
				return b[1] - a[1];
			}
		})

		//simplify list
		var finalHostServerList = [];
		for (var a = 0; a < hostServerList.length; a++) {
			if (0 >= finalHostServerList.length) {
				finalHostServerList = [hostServerList[a][0]];
			} else {
				//make sure all entries are unique
				if (finalHostServerList.includes(hostServerList[a][0])) continue;


				finalHostServerList.push(hostServerList[a][0]);
			}
		}

		return finalHostServerList;
	}
    
	function getAvailableRam(server) {
		var serverMaxRam = ns.getServerMaxRam(server);
		var serverUsedRam = ns.getServerUsedRam(server);
		if ('home' == server) serverMaxRam -= 32;
		return (serverMaxRam - serverUsedRam);
	}
	function getMaxThreads(server, script) {
		var serverRam = getAvailableRam(server);
		var scriptRam = ns.getScriptRam(script);

		return Math.floor(serverRam / scriptRam);
	}

	function calculateServerGrowth(server, threads, p, cores = 1) {
		const ServerBaseGrowthRate = 1.03;
		const ServerMaxGrowthRate = 1.0035
		const ServerGrowthRate = 1;
		const numServerGrowthCycles = Math.max(Math.floor(threads), 0);

		//Get adjusted growth rate, which accounts for server security
		const growthRate = ServerBaseGrowthRate;
		let adjGrowthRate = 1 + (growthRate - 1) / server.hackDifficulty;
		if (adjGrowthRate > ServerMaxGrowthRate) {
			adjGrowthRate = ServerMaxGrowthRate;
		}

		//Calculate adjusted server growth rate based on parameters
		const serverGrowthPercentage = server.serverGrowth / 100;
		const numServerGrowthCyclesAdjusted = numServerGrowthCycles * serverGrowthPercentage * ServerGrowthRate;

		//Apply serverGrowth for the calculated number of growth cycles
		const coreBonus = 1 + (cores - 1) / 16;
		return Math.pow(adjGrowthRate, numServerGrowthCyclesAdjusted * 1 /**p.hacking_grow_mult**/ * coreBonus);
	}
    

    var targetServer = ns.args[0];
    
    if(!ns.serverExists(targetServer)) return;
	ns.disableLog('ALL');
	ns.clearLog();





    while (true) {
        
    }
}